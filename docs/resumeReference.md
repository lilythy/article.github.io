![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612107309157-fd6eaed1-5b78-47fd-99a6-27a379d8f900.png?x-oss-process=image%2Fresize%2Cw_1342)

数盒0.4年 3个人  
云河测试平台0.3 2个人  
线上Excel平台0.2  2个人  
智能化代码和视图 0.5 3个人  
组件库 xxx

## 和上级分歧问题
这个得看原因，如果是双方的理解问题，那就可以通过流程图&&架构图，用图说话，这样可以减少理解成本，统一思路，表达也会比较清晰；如果是上级不认可方案的话，我觉得可以把整个方案的落地节奏&成果再细化一下，表达的更清楚一些，看看是哪一个环节有分歧，针对这个环节贴近业务看看有没有更好的解决方法，看看上级有什么疑问，或者上级有什么更好的方案，都可以一起讨论一下，对比看看各个方案的优缺点，综合选择最合适的方案

## 晋升问题
刚入职阿里评绩效的时候，入职时间没有满一年，不能参与评选。然后去年的话主管一开始给我提了晋升，但是同时主管也提了离职+组织架构调整，我换了新的主管，新的主管希望我把名额给团队资深的老员工，保证团队的稳定，答应今年会给我机会晋升，今年的话在阿里可以晋升，但是我们评绩效还要几个月，要等到6，7月份晋升答辩。也了解到腾讯这边的hc比较紧张，自己对腾讯还是比较向往，所以还是想着先来腾讯了，总是要取舍的，想着还是跟着自己的心，选择对自己来说更重要的八。

## 不留阿里的原因
腾讯比较稳定，组织调整较少；我们BU组织调整很快，一年换几任老板，业务规划摇摆不定，比较看不清楚方向，无法积累沉淀。对自己的提升、技术沉淀什么的帮助较少，希望自己能有更好的发展的平台，担任更大的责任与挑战

## 腾讯
腾讯这边目前的定位是创新孵化器  
现在有三块业务：  
1.电商，去年5月份开始对标拼多多的一款社交拼团产品。  
2.21年会基于社交，内容生态给腾讯内部媒体商业化赋能做一个电商中台  
3.一些其他的陌生人社交还有视频社交的产品研发  

## 小鹅pingping
不过腾讯没有选择APP形式，而是选择小程序进行入驻电商平台，目的是**为了让用户在微信平台内自生长，直接在微信内搜索小程序进行购买，让流量在社交平台之内可以自转化**。  
腾讯旗下微信、QQ等产品背后有着超大的**人口流量红利**。

其中，微信手握近12亿活跃用户，QQ的活跃用户也高达6亿，这是腾讯布局电商的巨大优势，流量充足。腾讯想将自身打造为**兼具社交和电商的双平台**，最主要的目的就是避免流量不断流失的风险。

## 没升的原因/离职原因
### 离职的原因
7月底原老板离职组织架构调整到了一个新的团队，新团队里2个技术平台坑位都满了，聊了几次还是不缺人，那2个月在负责一些零散需求，只抽离了一些常用组件以及和后端多个团队约定了接口规范便捷开发，对个人成长来说，没有发展  
腾讯比较稳定，组织调整较少；我们BU组织调整很快，一年换几任老板，业务规划摇摆不定，看不清楚方向，无法积累沉淀。公司架构调整，我的职位有变化.....以前我负责数据可视化搭建，智能平台等。现在我负责一些门店业务，和3D图像渲染相关的。我的优势无法得到发挥。  
### 没升的原因
入职离职异动  
 为了团队的稳定，对稍微倾向于资历比较深的员工，把更多的机会优先给他们

 ## 目前BU的方向
- **hcm：是盒马云消息系统，主要用于钉钉消息推送**
- **hlang：是可视化编排系统，主要用于流程节点的编排，目前使用改系统的有mall auto setup系统，门店sop系统。**
- **HRIM：可视化编辑器支持2D/3D预览渲染**

## 优点
+ 乐观皮实，在业务压力很大的情况下，也能比较好的去调节自己。
+ 能够贴着业务发现痛点，像我们BU这样把经营作业和数据托管放在云端的场景，对架构的可扩展性，可用性都提出了很高的要求。我作为一个数据前端，可以比较敏锐的识别到数据背后的业务痛点，力求用最佳的数据表达来进行数据可视化展示，努力使用数据驱动业务的提升和发展。（看情况说）
+ 行动派，可能有人会说要想好了再去做什么的，但是其实事实是很多事情如果不迈出行动的这第一步是永远想不好的，因此对我自己来说的话，有想法的话，我会先做，先行动。因此很多项目从开始设计到最后落地会比较高效吧
+ 健谈，沟通能力强。

## 缺点
+ 有时候比较急躁：有很多时候产品上线时间都是倒推的，在这个紧张的时间节点里，还在经常开会讨论确定产品的流程和细节，而且有的时候产品调整还要和开发重新约定接口，联调，重复的返工，打乱自己的计划，会比较焦躁  

+ 在项目中，自己遇到的难点和一些问题，可能有的时候没有及时去跟主管讨论，以后会多把自己的想法和总结的问题 和主管沟通这样

## 选择这个公司的原因(2B/2C)
盒马和蚂蚁来说 一个是tob 一个是toc  
“首先，我觉得每一个前端都必备的一个技能就是学习能力，前端技术栈每几年就一个迭代jquery -> angular -> react，**持续学习的能力显得很重要，目前to B的开发流程、组件库、调试工具等等在集团都相对成熟了，我才毕业2年，还有一股拼劲；另外，我觉得不一定要把每一个同学都放在ta熟悉的领域，这样工作起来虽然得心应手，但是同时也给自己设定了边界**，比如集团前端委员会每几年都会有一个新的方向，比如智能化方向，这个就跟算法、AI、图像识别等等相关，并不是前端熟练的领域，但是可以把自己的固有的界限打破，扩散自己的思维，寻找更多的方向，探索更大的可能性”  
做B端产品最大的挑战，是你要解决的问题并不来自你的用户，或者说你要满足的不是你的用户。真正使用你的产品或者解决方案的人，都不是提需求的人。这是其一，其二是决策，B端产品的决策也不是你的用户说了算的（我不是说管理层一定不会去用你的产品，只是从操作层面来说，基本上都是有普通员工来完成）。  
这个C端产品的区别就非常明显了。C端产品永远都是消费者自己说了算。作为消费者，我知道我的需求，我可以反映我的需求，我能决定我买还是不买。2B产品价值大于易用。  
B价值大于易用，2C易用大于价值  
C启于体验，B重在价值  
2B产品的是理性至上，注重业务梳理，功能明确。to business。  
2C产品是感性至上，注重用户体验，产品交互，to customer。  
2C市场：夜市摆地摊市场（个人摆摊卖给个人）  
2B市场：水果批发市场（果农批发给水果店）  
电商2B：阿里巴巴批发市场（生产商批发商品给零售商）  
电商2C：淘宝，天猫，京东（卖东西给个人消费者）  
电商B2C：天猫，京东（品牌商卖东西给个人消费者） 类似百货商场  
电商C2C：淘宝（个人卖东西给个人消费者）              类似夜市摆摊  
2B批发市场卖的产品需求特点：质量，安全，稳定，成本，专业，规模  
2C交易市场卖的产品需求特点：便宜，新鲜，有趣，便捷，体验，好用  


2.盒马和蚂蚁很多不一样的业务场景，而且自己比较感兴趣的智能识别方向在盒马没有场景，
比如：lowcode+智能化研发链路  
通过**工具链**，完成研发流程中高度**自动化、可沉淀复用、可智能化**的开发工作，实现**规模化提效、自动化沉淀复用、智能化研发**新工作链路。  
和之前面聊的主管以及自己对蚂蚁的了解，蚂蚁还是有很多智能化的方向，比如  
**智能化方向：支付宝余额宝等利用数据回流，分析用户特色，圈定不同人群，推荐不同功能** 
**模型选择：马尔科夫模型，RNN，LSTM，协同过滤推荐，基于内容推荐**  

![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1608110757284-ad7d4a0f-cc54-479f-b1fb-bc4236a27b69.png?x-oss-process=image%2Fresize%2Cw_1466)

**自己做过行为预测算法的demo,算法选型** 
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1608713019476-ae47b958-f442-4fe3-854b-d9f61817ab55.png?x-oss-process=image%2Fresize%2Cw_1466)

# 难点
## 1.数据前端感想
我们小组是做可视化和智能搭建平台，像这样把经营作业和数据托管放在云端的场景，对架构的可扩展性，可用性都提出了很高的要求。因此，希望自己作为一个数据前端，今后可以敏锐识别到数据背后的业务痛点，**用最佳的数据表达来进行数据可视化展示**，努力使用数据驱动业务的提升和发展。同时努力提升自己的业务和技术能力，总结做事的方法论。

## 2.数盒-模型选择-olap
对于一个常年做搭建产品的同学来讲，可能会觉得数据可视化搭建有什么难的，不就是用个接口把数据捞出来，然后做个图表展示不就行了。其实完全不是的，
**盒马主要面临的问题，不是“报表搭建的困难”，而是“数据产品交付困难”**  
盒马这边是存在metrics/http等比较个性的数据源，开发和联调成本都非常高，主要是开发者并不懂数据的意义，只能去了解到数据有哪些字段。因此，为了解决这个问题，并且无缝对接盒马数据源，选择使用数据分析的OLAP方式去做数据对接。
OLAP是一种数据动态分析模型，他。。。。
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1608107773410-86345d2f-522e-431f-a8f6-f328be70408e.png?x-oss-process=image%2Fresize%2Cw_1466)

## 3.开发通用业务组件库并推广
### 盒马使用的组件库（基于fusion
目前阿里的组件库有很多个，其中antdesign和fusion
在集团我们用的是fusion, 外界大部分用的antesign
fusion虽然开源时间比较晚，但是是针对于中后台这种场景的，已经覆盖了集团80%的部门，而且我们的团队就是开发fusion的那一拨人，所以我们优先选择fusion组件，我们BU的hippo组件就是底层用fusion，外面包了皮肤  
### 困难
在我刚入职我们这个BU的时候，对整个BU来说，我们面对的研发窘态是
我们需要沉淀最佳体验范式，统一用户心智，建立开发标准与规范，定义业务域最佳研发范式，抽象业务场景，抽象业务组件，推动跨端场景的能力复用
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607785164232-c7b5b2ec-43f1-4d7f-95d6-d9bfb05b806a.png?x-oss-process=image%2Fresize%2Cw_1466)

### 推广和落地的问题
对于很多从0到1的平台的推广和落地问题。  
技术上，需要加强前端同学对营销中台的理解，可以从整体看营销方案、互动玩法等。之前的很多需求，在整体方案上前端同学更多的是方案执行者，如果前端可以完全cover住一部分推广运营工作，也可以解放部分后端资源，帮助开发提效  
从业务上来说，也可以让前端同学从运营视角进一步了解业务打法，加深对业务的理解。也可以更加清晰的了解自己开发的产品项目可以帮助业务方解决的业务痛点是什么，以及自己产品的优势和亮点，适用的人群，和可以覆盖的业务场景这些。  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1615359049314-3e417382-4fdc-4c23-93bd-10d62943b239.png)

## 组件库推广问题
---别人为什么就使用你的组件库 你的组件库有什么特色  
- 问题  
我们发现BU组件散乱，不成体系，每个业务域都有自己业务域的组件包，甚至有些组件写死在业务仓库。使用的话，需要将每个npm包都接进去，然后了解很多仓库，很多团队文档，对于没有文档的，例如属性配置什么的还要去看代码实现，费时费力。功能重复，视觉交互不一致；api使用习惯不统一等等。
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1613985476918-5f7db8ff-6817-40c7-8241-a65ba8400c1e.png?x-oss-process=image%2Fresize%2Cw_1114)

- 目标  
期望整个团队可以只有一套业务组件库，别人引用的话 也只需要引用一份即可
- 推广难点  
怎么去包装统一的组件，并且推广到人人开箱即用。
- 特点  
**1.提供完善的基础服务**  
说明文档规范友好，并且可以帮用户自动生成组件文档，开发者不用去手撸文档。
技术点：  
hippo组件库底层用了 @ali/doc-parser这样的技术包，可以自动读组件（例如input组件）的参数，快速生成文档文件。即把里面的propsType提取出来，读取组件文件的propsType ，直接生成markdown文件。
怎么读参数？业界有一个库reactdocn，就是一个包，会提供API把组件属性都读出来
包怎么实现？用ast标准语法树，可以把js,ts转为标准的语法树  
**2.提供便捷的服务**  
可以快速生成组件目录及所有文件，通过fs（node 的一个库用来写文件读文件）  
**3.快速对接hippo官网**  
生成组件文档和BU组件官网打通，用户在这个hippo平台可以看到业务组件也可以用到技术组件  
**4.安全生产**  
引进的组件库里有很多组件，如果引入不规范会有bug，通过eslint codereviw （有个onwer）  
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607787085261-6b872e12-2cfb-41cd-a0af-12dd62e7c20f.png?x-oss-process=image%2Fresize%2Cw_1466)  

## 如何实现组件按需加载
Tree Shaking指的就是当我引入一个模块的时候，我不引入这个模块的所有代码，我只引入我需要的代码，这就需要借助webpack里面自带的Tree Shaking这个功能，帮助我们实现。Tree Shaking只支持ES Module(import....) 不支持require....  
把所有组件发cdn，import cdnpath  
import Button from 'https://unpkg.com/hippo/button.js'  
cdn for js module，只引用使用到的组件，相当于组件优化  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614915977815-b176f3b9-690f-4bcb-9157-2e9adfa000a1.png?x-oss-process=image%2Fresize%2Cw_1466)  

基于webpack Code Splitting实现react组件的按需加载  
其实组件写到最后一级目录就是 code split的一种实现  
[https://zhuanlan.zhihu.com/p/26228500](https://zhuanlan.zhihu.com/p/26228500)  

## 开发的组件
### 交叉表（透视表）
- 背景：  
  财务报表表格复杂，左边是可以展开收起的树，总的营销，总的成本，点开这个成本，还有两个子节点，比如门店成本，配送成本或者物流成本，可以不断的进行展开和收拢，表格的上面也是一颗树，比如按我们 BU会分商家，子公司，门店这样三层结构，因此会发现这个表格的左边和上面都是一颗树，这个就是和普通表格差别比较大的一点，以前行和列的数据是异构的（就是行的数据和列的数据就很不一样的），现在的话，行和列的数据结构是一样的，这个时候对于行列同构的情况用原来的表格结构无法满足。
- 思路：
在表格结构上  
那么这个时候我们就可以实现一个表格结构，输入就是行列同构的数据，实现的就是统一的，遍历左边数的叶子节点，上面树的叶子节点类似这样的一种新的渲染模型，实现一个最基本的交叉表的形式。以前的表格是行乘以列，而这个交叉表是左边一棵树乘以上面一棵树，这样子的话针对刚才说的财务报表这样的表格，就和业务本身的一些性质很符合，在开发过程中就不需要进行比较繁琐的数据转换了，我们就可以在表格结构这一方面可以和业务数据直接匹配起来  
数据处理上面  
后端同学提供的接口的数据格式和前端最终要展示在表格中的数据格式一般都是不对应的，中间的转换过程会比较复杂，数据的组织不太同，后端从数据库里查出来的是行列结构，渲染的时候是树状的结构，中间就有一层把平铺的数据转换为树状结构的一个过程，第二就是数据粒度的问题，提供的某一条数据和表格的单元格的行列的对应不起来的，有的时候需要进行一些额外的聚合，比如说里面有成本和收入，把成本和收入做个减法，可以算出毛利额或者净利润这样的值，那你把门店的所有收入加起来就能得到子公司的所有收入，也就是数据粒度或者指标口径在这个前端后接口层和最终展现在表格中的视图层两边是不一致的，那么就会有大量的数据转换逻辑，有很多可以抽象的地方，平铺数据怎么转换为树状数据，可以有一个比较简单的约定，id,parentId,第二就是说后端怎么在一个接口里提供不同数据粒度的明细数据，有些简单情况下面前端可以根据明细数据在前端进行区分计算，得到粒度更加粗的数据，可以抽象为通用的方法（业务数据转换为视图数据的时候可以沉淀通用的方法）有一些交叉表的交互，收拢展开，排序等，有些是表格功能，也可以抽象为数据处理的逻辑。  
- 用法  
1)通过 leftTree 描述表格左侧的树状结构；  
2)通过 topTree 描述表格上方的树状结构；  
3)通过 getValue 来定义每个单元格的内容；  
4)交叉表组件会根据 leftTree/topTree 来渲染表格结构，并调用 getValue 获取单元格的内容  
- 技术实现  
  视图和数据处理逻辑进行隔离，当我设计交叉表的时候，只关心表格的视图结构，左边一棵树用的最简单的树型结构  
  1、主要属性：
  1）key 用于在树中唯一标记一个节点；  
2）value 表示节点中的文本值；  
3）children 为子节点数组；  
2、可选属性：  
1）title若非空，被渲染在页面中时，节点内容将由 title 提供  
  在不是页面渲染的情况下（例如导出到文件），title 将被忽略
2）hidden 表示是否隐藏节点   
3）data为附加在节点上的数据  
data 中可以放任何内容   
放在节点中的数据，可在渲染单元格时取出，用于决定渲染结果   
左边和上面是同构的，数据结构也是完全一样的，交叉表就是左边的树乘以上面的树，因此中间数据部分的每一个单元格都有一个对应的左节点和上节点，节点内容选择了回调函数的形式进行实现，比如说有个render方法，要求用户传一个render 方法进来，那么针对表格中的每一个单元格，render都会调用一次，当被调用的时候可以获取到左节点和上节点，其实交叉树就是对左边的树进行遍历，再对上面的树进行一次遍历，两层循环，不断的调这个render方法，因为交叉表大部分时候都有一些大数据量的情况，几百行几百列，根据表格的当前视口，对行列进行过滤，这样子做一个虚拟滚动，大大优化表格性能。  
- 交叉表和普通表格的区别
  交叉表的底层依赖了 BaseTable，故两者的 props 大部分是相同的。两者的不同点具体如下：  
  1. 交叉表没有 dataSource 和 columns
   表格结构由 leftTree 和 rightTree 提供，而单元格内容由 getValue 提供  
单元格渲染内容可使用 render 进行自定义；单元格的 props（即表格内的 td 元素）可使用 getCellProps 进行自定义  
  2. 交叉表没有 primaryKey  
   交叉表左侧树中每个节点都有一个唯一的 key 值，故不再需要上层指定 primaryKey
  3. 其他新增的 props  
   交叉表使用 leftMetaColumns 来描述 leftTree 所处的列的配置  
   (交叉表渲染时，左侧的树会占据表格的前几列，并自动设置 lock=true，leftMetaColumns 可用于自定义这些列)  
   leftTotalNode：当 leftTree 为空时，leftTotalNode 用于渲染「总计行」，避免表格中没有数据行  
topTotalNode：当 topTree 为空时，topTotalNode 用于渲染「总计列」，避免表格中没有数据列  

## 组件跨端问题
**背景**  
在业务上，集团的中后台场景大多比较相似，通常以 PC 技术为主，用户主要在指定的工作台中完成日常工作。但在盒马，存在一个比较大的差异点就是流程上的跨端协同，门店、仓内、采购等多数场景存在普遍的跨端办公需求，典型的包括审批，巡检，看数等等，由于缺乏足够的体验层收口，跨端页面缺乏标准化的设计指导，使得交付的页面存在较大的体验差异。  
在开发侧，Hippo 1.0 面向不同端的分别提供了不同的组件包和工程工具，多套方案带来了基础设施的重复、API 的差异、以及答疑成本的升高，并且在可视化搭建和日常研发场景也存在差异化的实现方案。另一方面，当一个页面存在多端场景复用需求时，可能会被分发到不同的开发者进行分别实现，并且代码无法复用。  
**多端适配，一套代码适配多端**  
在调研了盒马的典型跨端场景后，可以看出多端共享一套设计体系是可行的。
组件层多端适配的目的就是复用一套代码服务多端，并根据不同端的特性进行 UI 层的适配。
**方式：**我们在同一套 Design Token 的基础上，通过构建多端适配层来差异化组件在多端的 UI 配置，同一个组件在共享核心代码的同时，面向不同的端暴露不同的出口文件，在出口文件中限定端的能力适配。  
在**组件层多端适配**上，Hippo 组件解决三方方面的问题：  
1. 多端排版的差异化问题。在 PC 场景我们通常采用 px 作为宽度单位，但在手机上，由于存在较多差异化的屏幕分辨率，使得页面适配变成一个棘手的问题。考虑到与 Rax 体系的兼容，Hippo 选择使用 vw 作为移动端的排版尺寸适配单位。
2. 多端样式的差异化问题。Fusion 的主题化机制为组件包提供了快速主体化的能力，同样我们需要一套类似的能力解决多端样式适配的问题，为此我们引入面向设备的 ThemeProvider 方案，并基于 CSSinJS 方案实现面向不同端的 UI 适配问题。
3. 多端实现的差异化问题。在调研已有场景后，我们认为所有的通用基础能力是可以跨端复用的，并且大部分的 UI 组件是可以跨端复用的，为此我们只需要解决面向移动端的功能适配问题即可，典型的包括移动端普遍使用的手势操作。  
   已表格组件为例，在 PC 端和移动端对表格有不同的数据分析需求，PC 上会倾向于更详情的数据展示，更丰富的交互体验，而移动端则更多关注核心的数据指标，并且交互逻辑也相对较少。为此，针对表格，下面的代码展示了面向不同端的能力组合示例：
```javascript
// table/index.jsx
export default [
    [withTree], [withSelectable], [withExpand], [withLock], [withRequest], [withConfig]
].reduce((prev, [enhance, ...args]) => {
  prev = enhance(prev, ...args);
  return prev;
}, BaseTable);
// table/phone/index.jsx
export default export default [
    [withTree], [withLock], [withRequest], [withConfig, { theme: phoneTheme }],
].reduce((prev, [enhance, ...args]) => {
  prev = enhance(prev, ...args);
  return prev;
}, BaseTable);
```

## schema生成页面
### 抽象业务场景，schema生成页面
**(解决表单场景，和后端约定字段规则，前端抽象SDK根据和后端约定的json schema 生成页面)**
- 做业务的时候发现，同一业务域或者同一功能不同设计师出的交互稿可能不太一样，导致类似场景给用户不一样的操作体验，同时提高了前端的开发成本，所以很重要的一件事是和交互一起建立场景最佳体验范式，统一用户心智。  
- 有了场景化的最佳体验范式后，就可以根据场景抽象业务模版，对抽象业务模版进行下分类，常规的模版比如列表，表单，详情；还有一些特色业务模版，比如审批流，人事schema模版等。  
- 就拿人事schema模版来说，因为人事业务核心流程之一就是人员的入职和离职，其中的痛点是人员类型多，不同类型模块差异大，业务主链路不完善，迭代频繁；交互也比较复杂，开发工作量很大  
- 针对这样的人事场景我的解决方案是抽象一套schema的模版  
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607786609492-80ed6db9-0852-4e74-b317-d7e9a2d2dff0.png?x-oss-process=image%2Fresize%2Cw_1466)

前端调用后端的schema生成页面，扩展到其他员工类型，前端基本不需要投入  
schema不能解决通用场景，否则会设计的很复杂，需要针对某个场景来解决。  
例如针对某个场景来解决列表，表单，联动等。  
和后端约定一套针对表单场景的规范。每个表单里面每个字段每个区块渲染成什么组件，比如一个下拉框里面获取数据的方式有多种，有通过本地数据获取的数据源，也有通过远程数据获取数据源，这个时候可以通过一个字段source为local/remote判断，若为local，后端直接返回一个数组，若为remote，后端返回一个url.
获取远程数据源需要传参数，怎么获取参数呢，首先增加一个参数params字段，参数分为固定参数/上下文参数，如果是固定参数的话，值为一个常量，如果是上下文获取的参数，设置成current.name这样，带到接口里面去。  
同时因为根据一个场景渲染的表单，每个字段是否显示/隐藏这个是否启用是后端判断的，可以加一个字段来展示哪些字段是显示的。  
表单联动问题，例如国家城市组件，城市会根据国家来变。组件内部会有一套联动的规则，设置一个一个字段为parent（国家），监听这个组件，国家变化，数据也要跟着变化。  
**加字段减字段，加模块减模块前端不需要任何改变的。**  
因为这个schema是跟后端约定的，而且是通过后端接口返回的，所以页面的加字段减字段，加模块减模块迭代等 前端不用跟着改。  
**模块校验怎么做？**  
约定了一套规则，会根据后端返回的报错信息，去查找是哪个组件有问题。每个组件都有个唯一的key，给那个组件加上报错信息即可。通过fusion里面的组件field的setError直接得到error信息。  
**怎么快速生成页面？**  
后端有个配置平台发布 diomnd 通过这个平台配置不同的schema, 然后前端就可以建立不同页面，去调后端接口。不同的schema生成不同的页面,前端不用投入,直接调用初始化封装的schema组件就行，不需要开发什么。  

# 技术
## 数据前端感想
像盒马这样把经营作业和数据托管放在云端的场景，对架构的可扩展性，可用性都提出了很高的要求。因此，希望自己作为一个数据前端，今后可以敏锐识别到数据背后的业务痛点，用最佳的数据表达来进行数据可视化展示，努力使用数据驱动业务的提升和发展。同时努力提升自己的业务和技术能力，总结做事的方法论。  
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607785164232-c7b5b2ec-43f1-4d7f-95d6-d9bfb05b806a.png?x-oss-process=image%2Fresize%2Cw_1466)

## 接口规范
请求格式:
```javascript
// 分页字段
{
    "pageNo": 1,
    "pageSize": 20
}
```

响应格式:  
```javascript
{
    "code": 200,      // {String|Number} 业务代码, 不是 http 代码 (由业务自行决定)
    "success": true,  // {Boolean} 处理是否成功
    "message": "OK",  // {String} 响应消息内容, 如果 success = false 时, 应该是错误消息
    "errors": [],     // {Array|Object} 更加结构化的错误消息 (如表单错误)
    "data": [         // {Array} 数据列表/树形类型
        {
            "label": "选项1",
            "value": "值",
            "children": [ ... ] // 当 data 为树形时, 节点可能会有 children 属性
        }
    ],
    "data": {         // {Object} 列表数据 (带分页)
        "list": [],
        "total": 1234,
        "pageNo": 1,
        "pageSize": 20
    },
    "data": {         // {Object} 对象数据
        "id": 111,
        "name": "foobar",
        "type": "none"
    }
}
```

使用方式：
```javascript
import { createService, batchCreateServices, normalizer, formatter  } from '@alife/hippo-request-service';

// 指定不同环境 (_APIMAP_ENV) 下的 API 域名映射 (如果是数字表示 mock ID)
const apienv = {
  'item.hemaos.com': {
    // mock
    local: 1111,
    pre: 'pre-item.hemaos.com',
  }
}

// 默认的配置, service 的配置会与默认配置合并
const defaultConfig = {
  onError: err => {
    alert('出现错误: ' + err.message)
  }
}

// 批量创建多个 service (支持 apienv 和 defaultConfig)
const service = batchCreateServices({
  getExampleData: {
    url: '//item.hemaos.com/api/example.json',
    method: 'get',
    normalizer: normalizer(
      pageSize: 'recordSize'
    ),
    formatter: formatter('treeList', {
      message: 'errDesc',
    }, {
      value: 'id',
      label: 'name'
    })
  },
  createSomething: {
    url: '//itme.hemaos.com/api/createSomthing',
    method: 'post'
  }
}, apienv, defaultConfig)

// 创建单个 service (支持 apienv, 不支持 defaultConfig, 也没有必要支持)
const getExampleData = createService({
  url: '//item.hemaos.com/api/example.json',
  method: 'get',
  normalizer: normalizer(
    pageSize: 'recordSize'
  ),
  formatter: formatter('treeList', {
    message: 'errDesc',
  }, {
    value: 'id',
    label: 'name'
  })
}, apienv)
```

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614157866083-3a7a9284-c7ce-4e6f-8db9-afc860bb3180.png)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614013834046-928fd1ef-6d09-4264-ab79-493ff0ecee88.png?x-oss-process=image%2Fresize%2Cw_733)

研发规范（接口规范，技术栈)
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607785123267-71e16668-57ff-4d19-bec9-249997d04ea1.png?x-oss-process=image%2Fresize%2Cw_1466)
抽象业务场景
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607786211387-cb5b4974-a56e-4710-90a2-7286cf0bbfbe.png?x-oss-process=image%2Fresize%2Cw_1466)

![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607787085261-6b872e12-2cfb-41cd-a0af-12dd62e7c20f.png?x-oss-process=image%2Fresize%2Cw_1466)  

![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607787377011-45407533-fc51-4708-a500-a3f9145a1100.png?x-oss-process=image%2Fresize%2Cw_1466)

## faas
function as a service  
faas简单理解就是封装的sdk，直接调用里面的函数去实现某一功能，不用管内部的实现，例如 legion 的service方法  

## 微前端
微前端，可能就是类似盒马的微应用，可以加载不同技术栈的页面，对比他们可能是weex，rax，h5等
https://qiankun.umijs.org/zh/guide  
微前端架构具备以下几个核心价值：  
- 技术栈无关
  主框架不限制接入应用的技术栈，微应用具备完全自主权
- 独立开发、独立部署  
  微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
- 增量升级
  在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略  
- 独立运行时  
  每个微应用之间状态隔离，运行时状态不共享  

## 跨端技术
js sdk 兼容(容器 -> 环境 -> h5/小程序，端：淘宝、支付宝)  
ast -> 基于一份代码按照各种代码开发规范转为多端代码  

# 规划
## lowcode+智能化研发链路
https://imgcook.taobao.org/?spm=ata.13261165.0.0.32716f1eY9bVpL
通过工具链，完成研发流程中高度自动化、可沉淀复用、可智能化的开发工作，实现规模化提效、自动化沉淀复用、智能化研发新工作链路。  
- 集团Low code / No code的技术趋势   
**ImageCook** 
自成闭环的智能研发体系（需求2代码方向共建）  
**天马、凤蝶、宜搭**  
可视化搭建  
- 多端DSL发展趋势
  **Rax化的一致化进程**
  各端接入Rax  
  **支付宝小程序的标准覆盖**
  DSL一致化  
  IDE一致化  
  发布标准一致化  
- 智能中台建设
  **设计中间件：上下游整合，工具链路**  
  http://kitchen.alipay.com/  
  https://fusion.design/tool  
  **Ant/Fusion**  
  ### 视图和代码的转换
  分工问题：imagecook主要有阿里智能方向部门实现，我们主要实现代码与视图部分
imagecook只是一个新特性，可以利用这个特性来将页面转为代码  
**产物：**就是所有代码文件(这个页面的所有js,css)  
**特点**  
- 我们这个是拖拽组件生成页面的搭建平台，常用组件都是快捷操作即智能向导，就不需要写代码，只需一步一步配置，完全为后端，测试等不熟悉前端代码的同学设置，这些前端同学也能快速上手，不需要写js代码。
- 所有的视图都是根据仓库的代码来生成的  
     好处是 即使搭建系统后面不再维护或者搭建新的特性没更上，都可以本地去发布代码，不会影响迭代的进度
- 拉文件是从数据库里和gitlab上去拉取
- 发布的话，生产代码和gitlab仓库打通再和galaxy平台打通  
**技术选型**   
**schema VS Ast**
目前社区上大多数搭建服务都是基于 json schema 实现的，然后对比一下 schema vs ast 的优缺点；schema 对于复杂的页面编辑成本很高，不断扩充的协议，解析渲染受限等等；再说一下 ast 的应用：视图转换、代码升级、定制出码等  

schema  
优点：易操作，学习成本低，我们对json比较熟悉方便，不管是后端对接还是写数据结构都用的json。会比较简单直观人机可读  
缺点：但是对于一个页面，用json描述的话，层级结构会越来越深，如果是很复杂的大表单，往表单里加字端，就很冗长。层次结构很深的话，渲染也就很慢，因为需要一层一层的遍历，把它还原成组件的实例，而且json很受限制，如果不满足需求，需要扩充协议，不断扩充，无限膨胀，后面就很麻烦  
而且类型不严谨，复杂场景正则匹配不精确，比如代码注释，function函数定义，chass类的定义，文件格式化缩进等。  
需要一个解析器渲染器，把json还原成真正的jsx;  


ast  
抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。也就是说，对于一种具体编程语言下的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。  
因此我们选择ast实现视图和代码的转换  
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607875825849-f8db15fb-1ffd-4813-b710-5725ba26bdfe.png?x-oss-process=image%2Fresize%2Cw_1466)

**实现过程**
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1608116429900-f5c65965-8fac-43da-acb0-4e7948b7d54b.png?x-oss-process=image%2Fresize%2Cw_1466)

**加载文件**
业务文件通过seajs.use加载文件  
业务组件通过将业务组件的npm包发到cdn，然后通过seajs加载  
常用公共依赖，把他们通过umd的模块打包方式发布到cdn, 注入vm，  

**保存**  
同步到gitlab和sql  

**视图数据改变->代码改变**
- 确认组件：jquery的方法，通过closest方法知道目前鼠标焦点的是哪个组件
- 找到用户操作的属性：因为最开始拉文件的时候，就已经开始文件的分析，这些分析都储存在缓存里，包括把jsx文件转ast，分析ast里组件的依赖，每个组件包含的属性以及记录组件所在的文件等，所以可以知道用户操作的是哪个文件的哪个组件
- 将ast里面的属性改为用户修改的值，涉及到ast的一个操作，traverse用来操作ast的库。找到用户操作的属性，然后将代码转为ast ,再替换掉刚才修改的node节点
- 更新缓存，把ast转成代码jsx，再转成浏览器执行的代码
- 页面刷新，refresh时从缓存里加载最新修改的文件来执行
  ![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614592142199-a0ab8096-45f3-4166-a9a5-87ccbceaf53c.png?x-oss-process=image%2Fresize%2Cw_1466)

  **旁边配置项属性（组件注册）**
  组件注册，通过react-docgen, 将组件属性都生成，然后保存到sql  
解析出组件的propstype, 按照相应算法把propstype遍历，加到组件上，生成各种形态的组件实例  

**扩展seajs钩子做了什么**
业务组件和业务文件域名不一样，扩展的钩子帮你区分，帮转为ES5, 做缓存等  

**搭建平台组件库是怎么更新的**
在搭建里面：组件发布npm后，在组件中心更新一个版本号，把组件同步到最新的版本号，底层的操作就是把组件发布到cdn，同时生成最新的组件属性配置，就是组件属性schema，存储到数据库；在设计器打开页面时加载这个组件版本号对应的配置  

**Babel原理**
大多数JavaScript Parser遵循 estree 规范，Babel 最初基于 acorn 项目(轻量级现代 JavaScript 解析器) Babel大概分为三大部分：  
- 解析：将代码转换成 AST
  词法分析：将代码(字符串)分割为token流，即语法单元成的数组  
语法分析：分析token流(上面生成的数组)并生成 AST  
- 转换：访问 AST 的节点进行变换操作生产新的 AST  
  Taro就是利用 babel 完成的小程序语法转换  
- 生成：以新的 AST 为基础生成代码 


### 视图和代码之后的规划
#### 视图代码转化搭建平台的规划
我之前开发的代码和视图的互转的平台，系统针对的用户的角色比较单一，只针对前端和后端，功能也是辅助前端和后端开发页面，相当于是一个页面的搭建系统，目的是为了满足业务需求，生产页面。从我们平时研发的链路来看，只是其中的一个节点，我们可以把这个平台扩展到多端多角色的这样的一个研发协同平台。  
可以把我们研发链路中的业务角色都关联进来，系统可以满足多角色需求；在这个平台上实现SOP的研发链路，从产品评审到交互出视觉稿，到前后端开发，测试TC评审，提侧，发布等一系列流程都可以在这个平台完成，可以在这个平台将产品出的demo稿，交互出的视觉稿转为代码供开发使用，也可以随时关注到开发进度，可以和我们的测试平台打通，提供上线前的自动化回归测试，可以有个项目bug list大盘这样的模块，跟进bug修复程度，并且和发布平台打通，跟进前后端发布进度。  
特别对了产品和运营用户，  
产品可以在这个平台录入prd，demo稿等，将关联的所有需求人员都圈进来，产品录入prd可以选择两种方式，一种是提供很多原子的业务组件，通过拖拽的形式搭建出静态页面，去评审，并且可以直接转为代码，减少开发工作量。另一种是通过imagecook，它会提供一个插件，每个组件都会有标注，标注它的代码规范，可以根据这些标注生成代码，满足诉求。  

#### 结合imagecook新特性 
（imagecook主要有阿里智能方向部门实现，imagecook是一个新特性，可以利用这个特性来将页面转为代码  
**背景：**  
-移动端的页面场景单一 玩法单一 ，用户上传个UI页面就可直接生成页面的代码，开发只需要写好接口 或者封装好接口，代码初始化就好了  
-一些简单场景 列表 详情等页面直接自动渲染。  
-迭代的话，开发只需修修改改，就能快速上线  

**原理：** 
通过tensorflow， 就是为深度神经网络（DNN）开发的功能强大的开源软件库。  
数据训练的模型 一大堆数据丢给他 去训练算法   
为了保证识别的准确性=>大量的数据训练 和 调参数  
例如暂存一张图片 会和组件库里的组件去匹配 组件库里有所有组件的列表 每个组件会渲染出来不同的形态（下拉框单选多选 本地搜索远程搜索） 每个组件各种形态 通过获取组件dom结构=>再生成图(dom通过html2canvas转为image，上传到oss)存在组件库 ，因此组件库里的图片可以和用户上传的图片进行匹配，看用户用到哪个组件，就可以从交互稿生成代码  
（对于多种形态的组件，要把组件的所有场景都自动生成出来，常规的方法可以是基于组件文档，每个组件都有每个场景的形态，可以根据场景自动生成，而且场景是开发者手写的，开发者知道每个组件有哪些形态，哪些属性等；  
另一种方法是更具reactdocgen解析出组件的propstype, 按照相应算法把propstype遍历，加到组件上，生成各种各样的实例  ）  
TensorFlow 是由 Google Brain 团队为深度神经网络（DNN）开发的功能强大的开源软件库
开源深度学习库 TensorFlow 允许将深度神经网络的计算部署到任意数量的 CPU 或 GPU 的服务器、PC 或移动设备上，且只利用一个 TensorFlow API。你可能会问，还有很多其他的深度学习库，如 Torch、Theano、Caffe 和 MxNet，那 TensorFlow 与其他深度学习库的区别在哪里呢？包括 TensorFlow 在内的大多数深度学习库能够自动求导、开源、支持多种 CPU/GPU、拥有预训练模型，并支持常用的NN架构，如递归神经网络（RNN）、卷积神经网络（CNN）和深度置信网络（DBN）。  

**开发运营配置平台** 
因为视图和代码转化的这个搭建平台可以生成页面的代码，但是组件属性如果是前端写死的，发布到线上就是一个静态的，交互无法更改的页面，要更改的话需要前端去迭代，如果是日常业务迭代中的小需求的话，比如：文案的修改，表格行列的增删，表单字段or规则的修改，这些小需求每次都拉分支开发发布很耗费时间。  
可以开发一个运营配置平台与这个搭建平台结合，优化这里的问题。把这些修改频繁的交互配置到运营配置平台，由PD或运营去配置，前端直接读取数据渲染，小需求由PD或者运营自行开发。  
原理的话就是，比如页面上有个文案需要修改，运营根据场景去配置组件展示的时候，运营平台会去改组件的proptype， 然后会存个json数据，那张需要迭代的页面就调这个json数据（接口）去初始化组件就行，前端是无感知的。  
**搭建组件库和组件官网同步**
搭建组件库和组件官网同步  
（组件市场没有对应的业务组件，分支缺乏依赖包，组件官网新增了组件属性，搭建组件没有同步，导致基础组件缺乏属性支持）
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614937819130-198a9d07-07ed-42b2-a1d3-c9650f0ca8b8.png?x-oss-process=image%2Fresize%2Cw_1318)

老页面升级为搭建页面  
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607875334146-89c0abc8-758a-41a6-a31c-999c03396f22.png?x-oss-process=image%2Fresize%2Cw_1466)

![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607875218618-7ef9ab31-1078-4309-9a41-335c8d2ecc39.png?x-oss-process=image%2Fresize%2Cw_1466)
数据运营组织者衍生-运营+技术-前端同学不仅仅是方案执行者，随着营销活动常态化以及一些营销中台的完善，前端可以cover住一部分营销活动，可以解法部分后端资源 和运营资源，帮助开发提效。  

# RoyJS
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607874978989-5568aacc-9626-4946-95bc-8a87d1247b32.png?x-oss-process=image%2Fresize%2Cw_1466)

# BFF
服务于前端的后端
https://www.jianshu.com/p/9cca72f9e93c  
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1608032645573-ff9d9955-4199-48ce-bd40-576e82b8744a.png?x-oss-process=image%2Fresize%2Cw_1384)

# PAAS
https://www.jianshu.com/p/e3a32258db05  
 PAAS: Platform-as-a-Service(平台即服务)，第二层就是所谓的PAAS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。  
       PAAS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等  
# FLUX
https://www.jdon.com/idea/flux.html
Flux是Facebook用户建立客户端Web应用的前端架构，它通过利用一个单向的数据流补充了React的组合视图组件，这更是一种模式而非正式框架，你能够无需许多新代码情况下立即开始使用Flux。  
　　Flux应用有三个主要部分：Dispatcher调度 、存储Store和视图View(React 组件)，这些不应该和MVC:Model-View-Controll(模型-视图-控制器)混淆，控制器在Flux应用中是存在的，但是他们是controller-view(控制器-视图)，视图通常在一个结构顶部，而这种结构是用来从存储stroe获得数据，然后将数据传递到自己的子结构们，此外，Action创建者-Dispatcher的帮助类的方法 -用于支持一个语义API，这个API是描述应用程序中所有变化的可能，通常可将它们看成是Flux更新循环的第四部分。  
　　Flux是以单向数据流方式支持MVC，当一个用户和React视图交互时，视图会将这个动作传播到一个中央Dispatcher，一直到各种村粗，在那里保存着应用的数据和业务逻辑，这个使用React的声明式风格的过程是非常棒的，能够允许存储发送更新信息，而无需指定在状态之间如何切换视图。(传统方式更新状态后，会推出一个新的视图页面

# webpack
https://webpack.docschina.org/concepts/
本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。
可以在 这里 了解更多关于 JavaScript 模块和 webpack 模块的信息。
从 v4.0.0 开始，webpack 可以不用再引入一个配置文件来打包项目，然而，它仍然有着 高度可配置性，可以很好满足你的需求。

webpack使用https://www.yuque.com/chengkuan/web/nhms80  

# tnpm
把真实的包都安装在外层，所有包的依赖，都通过软链接方式，进一步提高复用性

包管理工具对比  
https://www.yuque.com/chengkuan/web/npm  
- npm 最原始的
- yarn facebook出品的
- tnpm 阿里内部使用的
- npminstall 可以通过lib包的方式使用，不必须依赖命令行
- tubro 在浏览器中工作，应用在stackblitz的webide

npm
https://www.runoob.com/nodejs/nodejs-npm.html  
NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：  
- 允许用户从NPM服务器下载别人编写的第三方包到本地使用。
- 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。
- 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。  
由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 "npm -v" 来测试是否成功安装。命令如下，出现版本提示表示安装成功:

# webExcel
**多人编辑**
思路  
Use Case 1：用户 a 编辑文档时，用户 b 点击编辑，提示用户 b 需等 a 完成后才能进入。  
Use Case 2：为了防止用户 a 打开文档后忘了关闭，导致其他用户都进不来，对于正在编辑文档的用户，做「发呆检测」。如果发呆期间（可定义发呆时间超过 5 分钟为发呆态），有用户 b 点击了编辑按钮，则自动保存用户 a 的数据到服务端，同时用户 a 的界面上弹窗有新用户进入编辑、数据已保存、再次进入编辑等提示，仅保存数据，不做任何发布等事宜。用户 a 回来，选择继续编辑时，先从服务端拉取最新数据。  
一定要让不需要多人加锁的绝大多数用户完全不知道这个功能，需要的时候，则自然而然能知道并学会使用这个功能。  

基本原理  
https://www.jianshu.com/p/d2ac26ca6525  
当程序中可能出现并发的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。这种手段就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。  
没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。  
实现并发控制的主要手段大致可以分为乐观并发控制和悲观并发控制两种。  
选择悲观锁，就是借助数据库锁机制，在修改数据之前先锁定，再修改
悲观锁是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，所以需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。悲观锁的实现：  
1.传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。  
2.Java 里面的同步 synchronized 关键字的实现。  

**文件下载**
基于node-xlsx 插件的build api 初始化每一列的表头以及数据；设置接口返回的Content-Type 为 application/octet-stream，设置Content-Disposition的文件名以及文件格式

**快速对接数据源**
node直接对接他们的数据表或者开放服务，包括我们BU的指标库信息，数据地图信息，FBI报表数据，底表数据，d2数据源
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614862660327-17675c62-c614-4315-adc9-088c67aa1cf2.png)

总述  
盒马一站式取数与在线Excel平台是为用户（运营小二等）定制的一款一站式的包含数据导入，加工分析，分享的平台。不仅可以将Excel的基本功能线上化，还可以实现多人编辑，快速对接数据源，实现数据实时刷新，公式计算，图表透视，分享等功能。极大程度上解决了线下Excel处理数据时，在上传和下载过程中，所造成的不可避免的数据版本的差异以及无法协同工作等一系列弊端，揭示了智能电子表格的未来之路。  
从前期的大量调研到完成了盒马一站式取数与在线Excel平台的产品模块设计，功能链路设计，使用流程及编辑快捷自动化数据计算公式等基础上，实现了盒马一站式取数与在线Excel平台的一期建设，在采购小二的试用及内部进一步的冒烟测试后，对平台的功能架构进行了优化。具体落实了若干采购小二平常所制作报表的典型案例场景，从数据导入，加工分析到分享这一体化流程，用户使用感良好，对于完成一张报表的制作，用户从之前的几个小时到现在的几十分钟，而对于更新一张报表，用户只需要进行简单的操作就可以即刻完成更新。真正意义上提高了采购和运营同学的工作效率，减少了采购和运营同学的日常报表制作成本，为在制作报表过程中，需要经历频繁复杂操作的小二们带来了新的曙光。盒马一站式取数与在线Excel平台，堪称给面对线下Excel焦虑迷茫小二们雪中送炭的治愈系法宝！  


# nodeJS
平时应用  
需要统计网站的url，可以通过node爬虫，爬去所有url，按顺序给我，我在终端用js把爬出的URL数据做js处理转换等，node导出到Excel里，  
简单的链接数据库，写接口，常用的增删改查  
链接数据库  
常用的crud增删改查  
https://blog.csdn.net/weixin_43221323/article/details/103787631

非阻塞io/nodejs异步原理  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614146519447-3fd08b7a-23e2-4584-aa18-809cf8b6bdeb.png?x-oss-process=image%2Fresize%2Cw_1296)

node事件循环eventloop  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614137098808-6ce98384-764a-4c38-b0f5-fa9a0cd3a6b3.png?x-oss-process=image%2Fresize%2Cw_716)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614137129640-e50d3d6a-f5e6-46e9-a4ab-d0e4e4374777.png?x-oss-process=image%2Fresize%2Cw_730)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614137148004-06142e76-a4e3-4e75-acbd-c4564d273c6e.png?x-oss-process=image%2Fresize%2Cw_724)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614137160921-362a5509-a76a-463d-97e0-2926c0d718c7.png?x-oss-process=image%2Fresize%2Cw_738)

#### egg-mysql  
https://eggjs.org/zh-cn/tutorials/mysql.html 
常用控件  
router -》controller -〉service(见代码管报)  
![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607763648604-dfd24f74-6bb4-41db-81c2-eef2056bd2de.png?x-oss-process=image%2Fresize%2Cw_1028)

![](https://cdn.nlark.com/yuque/0/2020/png/8371569/1607763648614-6a95246d-0e63-42a3-b44c-cee1351f49ed.png?x-oss-process=image%2Fresize%2Cw_1076)


#### EggJs
官网
https://eggjs.org/zh-cn/intro/egg-and-koa.html
概述  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612236502294-b42cf00b-6031-4b1c-90d8-3eecef564d07.png?x-oss-process=image%2Fresize%2Cw_1496)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612236578569-04ea0a79-7560-48f2-95c5-c01013ea1683.png?x-oss-process=image%2Fresize%2Cw_696)

与其他框架的差异  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612339139426-770bff60-0b9c-4b5a-ac6c-c8e64e741164.png?x-oss-process=image%2Fresize%2Cw_1496)

#### 渐进式开发
https://eggjs.org/zh-cn/tutorials/progressive.html
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612343552831-0c3baf39-906e-4f67-bd48-a8c0a218d675.png)

#### 框架内置对象
https://eggjs.org/zh-cn/basics/objects.html
框架中内置的一些基础对象，包括从 Koa 继承而来的 4 个对象（Application, Context, Request, Response) 以及框架扩展的一些对象（Controller, Service, Helper, Config, Logger），在后续的文档阅读中我们会经常遇到它们
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612345558612-c9183525-d59e-4567-9452-096cb1c982c5.png?x-oss-process=image%2Fresize%2Cw_432)

安装
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612236851852-708cde0c-0ed1-4ca1-8f73-b94a09551c37.png?x-oss-process=image%2Fresize%2Cw_984)

//具体安装和创建
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612237030857-29f920c2-630f-436a-aa8c-cc47f1b1d281.png)

egg框架结构
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612254146809-673a24d3-84c3-4a9a-aef4-2d9b3f705e9b.png?x-oss-process=image%2Fresize%2Cw_1496)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612239021513-5bfd4925-71c3-4046-9017-36e0d4234b00.png?x-oss-process=image%2Fresize%2Cw_1274)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612247551500-d76eb529-a0b1-4e05-96f1-b901acb6e1b9.png?x-oss-process=image%2Fresize%2Cw_718)

ejs使用  
安装  
配置插件  
配置模版引擎  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612253399725-06879856-b31b-49ab-bdb3-aafae18d7812.png?x-oss-process=image%2Fresize%2Cw_686)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612259748376-a2c7ff2a-365e-450e-b4ef-a436ce4729dc.png?x-oss-process=image%2Fresize%2Cw_1272)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612259778444-f48866ae-f5d7-4772-be25-3d1fc662eedd.png?x-oss-process=image%2Fresize%2Cw_1276)

服务里调用服务  
一个控制器可以调用多个服务，服务之间也可以相互调用  
服务不能调用控制器，控制器之间也不能相互调用  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612259976102-dc78aa79-f444-4f16-8e8f-a556b08ee70a.png?x-oss-process=image%2Fresize%2Cw_1276)

//controller里的组件要在router里面设置路由
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612323687227-24074277-e47f-4cc0-94a0-8af60ecf960a.png?x-oss-process=image%2Fresize%2Cw_1272)

服务的命名规则
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612260382927-1008e4ed-d986-494e-b0ea-ad0f6000663c.png?x-oss-process=image%2Fresize%2Cw_1496)

实际使用egg流程，从0搭建爬虫系统
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612265720833-1b558bac-a3c3-4f16-9491-affd3a4a3061.png?x-oss-process=image%2Fresize%2Cw_854)
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612265925872-539b225b-d33c-4640-9c23-028cd5ca4081.png?x-oss-process=image%2Fresize%2Cw_1420)
通过egg的curl方法获取远程的数据，也可通过node的http.get()
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612266342329-bb134adf-083e-4303-a4d4-f577c8910e68.png?x-oss-process=image%2Fresize%2Cw_1354)

**扩展模块extend**  
我们可以通过定义 app/extend/{application,context,request,response,helper}.js 来扩展 Koa 中对应的四个对象的原型
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612268879659-157bb4ff-17df-4e90-9cb0-5c51fc951ef7.png?x-oss-process=image%2Fresize%2Cw_1362)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612269152809-39ece770-bce7-407b-9de4-a96407a58d9a.png?x-oss-process=image%2Fresize%2Cw_1232)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612268805329-96a0b409-0737-44d1-90d6-7cf94143ef4c.png?x-oss-process=image%2Fresize%2Cw_1232)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612269048628-10f1e36c-5462-485e-ace8-04beb819e059.png?x-oss-process=image%2Fresize%2Cw_1238)

**eggjs利用cpu多核（进程管理）**  
https://www.axihe.com/edu/egg/core/cluster-and-ipc.html   
- 为什么cluster fork多份源码跑在多个子进程上没有报端口被占用？
 cluster模块会hack掉worker中的监听，端口仅由master的TCP服务监听了一次
- Master是如何处理请求转发的worker的？
  所有请求会统一经过内部TCP服务，符合一定负载均衡的挑选出一个worker并发送内部消息，该worker接收到消息后执行具体业务逻辑。(除 Windows 之外所有平台上的默认方法是循环方法,接受新的连接，并以循环方式将它们分发给各个工作线程，同时使用一些内置的智能，来实现负载均衡。)  
**综述** 
javscript的代码只能运行在单线程中，也就是一个nodejs进程只能运行在一个cpu上。如果需要充分利用多核cpu的并发优势，可以使用cluster模块。cluster能够创建多个子进程，每个进程都运行同一份代码，并且监听的是同一个端口。  
**Cluster**  
简单的说，  
- 在服务器上同时启动多个进程。
- 每个进程里都跑的是同一份源代码（好比把以前一个进程的工作分给多个进程去做）。
- 更神奇的是，这些进程可以同时监听一个端口（具体原理推荐阅读 @DavidCai1993 这篇 Cluster 实现原理）。
其中：  
- 负责启动其他进程的叫做 Master 进程，他好比是个『包工头』，不做具体的工作，只负责启动其他进程。
- 其他被启动的叫 Worker 进程，顾名思义就是干活的『工人』。它们接收请求，对外提供服务。
- Worker 进程的数量一般根据服务器的 CPU 核数来定，这样就可以完美利用多核资源

**Master / Agent / Worker**  
当一个应用启动时，会同时启动这三类进程。  
![](https://intranetproxy.alipay.com/skylark/lark/0/2021/png/87051/1626337094028-ecdd9082-7635-4278-b1b4-05e8b1f8bb90.png?x-oss-process=image%2Fresize%2Cw_1496)

Master  
在这个模型下，Master 进程承担了进程管理的工作（类似 pm2），不运行任何业务代码，我们只需要运行起一个 Master 进程它就会帮我们搞定所有的 Worker、Agent 进程的初始化以及重启等工作了。  
Master 进程的稳定性是极高的，线上运行时我们只需要通过 egg-scripts 后台运行通过 egg.startCluster 启动的 Master 进程就可以了，不再需要使用 pm2 等进程守护模块。  
$ egg-scripts start --daemon  

Agent  
在大部分情况下，我们在写业务代码的时候完全不用考虑 Agent 进程的存在，但是当我们遇到一些场景，只想让代码运行在一个进程上的时候，Agent 进程就到了发挥作用的时候了。  
用来处理一些后台运行逻辑，比如说打印日志，不需要在4个app worker上都去执行，不对外提供服务，只处理公共事务，所以稳定性相对来说是很高的。  
由于 Agent 只有一个，而且会负责许多维持连接的脏活累活，因此它不能轻易挂掉和重启，所以 Agent 进程在监听到未捕获异常时不会退出，但是会打印出错误日志，我们需要对日志中的未捕获异常提高警惕。  

Worker  
Worker 进程负责处理真正的用户请求和定时任务的处理。而 Egg 的定时任务也提供了只让一个 Worker 进程运行的能力，所以能够通过定时任务解决的问题就不要放到 Agent 上执行。  
Worker 运行的是业务代码，相对会比 Agent 和 Master 进程上运行的代码复杂度更高，稳定性也低一点，当 Worker 进程异常退出时，Master 进程会重启一个 Worker 进程。  


**进程启动顺序**
1. Master 启动后先 fork Agent 进程，同时监听'agent-exit, agent-start'事件，agent 启动成功后发送agent-start事件（IPC进程间通信）通知master
master监听到agent-exist事件会在一秒后再fork一次agent worker，保持agent稳定onAgentExit  
agent-start事件为once，即使重启了agent app worker也不受影响
2. Master收到 agent-start 通知fork多个App Worker，这里的fork用的是cfork包，负责 worker 的启动，状态监听以及 refork 操作，保证worker的数量
3. 多个App worker 启动成功后发送app-start事件通知到master
4. 所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功

**异常处理**  
异常可以简单分为两类，第一类是可以监听process.on('uncaughtException', handler)捕获的异常，通过监听事件可以使得进程不会异常推出还有机会可以继续执行。第二类是被系统杀死直接推出的异常。  
eggjs使用了graceful和egg-cluster让异常发生时master能够立刻fork出一个新的worker保持连接的worker数。  
**进程间通讯（IPC）**  
在nodejs中实现进程通信可以通过监听messgae事件实现  
cluster 的 IPC 通道只存在于 Master 和 Worker/Agent 之间，Worker 与 Agent 进程互相间是没有通讯通道的，他们之间通讯通过 Master 来转发。

**cluster源码原理**
从Node.js项目的lib/cluster.js中的代码
https://cnodejs.org/topic/56e84480833b7c8a0492e20c

**eggjs koa洋葱模型 中间件**
https://segmentfault.com/a/1190000013981513

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614136626498-4aff649f-dd7b-4f39-b4f4-89f38f9ca442.png?x-oss-process=image%2Fresize%2Cw_742)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614136730850-38c7fb9c-da04-40f6-994d-5cd6f6ef0cb8.png)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614136647390-7fd08e9c-99ec-4553-8e0f-06789843ffc9.png?x-oss-process=image%2Fresize%2Cw_716)

Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。  
Koa 和 Express 的设计风格非常类似，底层也都是共用的同一套 HTTP 基础库，但是有几个显著的区别，除了上面提到的默认异步解决方案之外，主要的特点还有下面几个。  
Koa 的中间件和 Express 不同，Koa 选择了洋葱圈模型。  
 Egg 是基于 Koa 实现的，所以 Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。每次我们编写一个中间件，就相当于在洋葱外面包了一层。  
所有的请求经过一个中间件的时候都会执行两次，对比 Express 形式的中间件，Koa 的模型可以非常方便的实现后置处理逻辑，对比 Koa 和 Express 的 Compress 中间件就可以明显的感受到 Koa 中间件模型的优势。  
- koa-compress for Koa.
- compression for Express.

**koa和compress中间件的区别**  
https://www.cnblogs.com/cckui/p/10991062.html  
koa2的中间件是通过 async await 实现的，中间件执行顺序是“洋葱圈”模型。  
中间件之间通过next函数联系,当一个中间件调用 next() 后，会将控制权交给下一个中间件, 直到下一个中间件不再执行 next() 后, 将会沿路折返,将控制权依次交换给前一个中间件。  

与 koa2 中间件不同的是，express中间件一个接一个的顺序执行, 通常会将 response 响应写在最后一个中间件中
主要特点：  
- app.use 用来注册中间件
- 遇到 http 请求，根据 path 和 method 判断触发哪些中间件
- 实现 next 机制，即上一个中间件会通过 next 触发下一个中间件

**常用的中间件**
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614136789756-ec1ad8e1-d57e-446e-ac1e-4ca1f80a6863.png?x-oss-process=image%2Fresize%2Cw_666)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614136566023-6998e5db-f696-439d-88e3-258a0dda947b.png?x-oss-process=image%2Fresize%2Cw_730)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614136599505-a8fb2548-b2b7-46aa-bc51-683ed14498ba.png)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612269485825-c12c7522-f67c-4c65-8abf-bcc2b8ed1764.png?x-oss-process=image%2Fresize%2Cw_1492)

**egg cookie**
https://www.axihe.com/edu/egg/core/cookie-and-session.html
介绍  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612283960403-fbf5d221-d497-4424-a257-510cd357bb31.png?x-oss-process=image%2Fresize%2Cw_1496)
设置和获取  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612283923941-768a282b-9c97-4f16-b4d4-063b189c89d6.png?x-oss-process=image%2Fresize%2Cw_906)

加密  
//如果数据加密以后就可以设置中文cookie（encrypt:true）  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612325346173-c6b4e950-0fd2-4e45-b8f0-46bc5d37e813.png?x-oss-process=image%2Fresize%2Cw_1204)

//获取加密的cookie，在这里面解密，设置encrypt为true
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612325258958-d44a7a0e-d6ca-471d-99ac-8cd744e3eca9.png?x-oss-process=image%2Fresize%2Cw_1210)

Cookie 秘钥
由于我们在 Cookie 中需要用到加解密和验签，所以需要配置一个秘钥供加密使用。在 config/config.default.js 中
`module.exports = {
  keys: 'key1,key2',
};`  
keys 配置成一个字符串，可以按照逗号分隔配置多个 key。Cookie 在使用这个配置进行加解密时：  
- 加密和加签时只会使用第一个秘钥。
- 解密和验签时会遍历 keys 进行解密。
如果我们想要更新 Cookie 的秘钥，但是又不希望之前设置到用户浏览器上的 Cookie 失效，可以将新的秘钥配置到 keys 最前面，等过一段时间之后再删去不需要的秘钥即可。

清除cookie  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612325532850-21efb935-d615-4866-aac3-57ef46b4dd26.png?x-oss-process=image%2Fresize%2Cw_1010)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612325631057-4efa957a-7d09-4fc0-93c3-e2eba3b195a6.png?x-oss-process=image%2Fresize%2Cw_1038)

egg session  
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612325694030-59f93e74-bcf7-4b4c-b97f-91f98bd46f54.png?x-oss-process=image%2Fresize%2Cw_1272)

session的工作流程
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612325738615-42ddfe8f-3bce-434b-9b93-c48617377175.png?x-oss-process=image%2Fresize%2Cw_1298)

session 设置和获取
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612325921467-cc5ab269-73d3-465b-92ff-207da78f577f.png?x-oss-process=image%2Fresize%2Cw_620)

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614053368781-ab8bfa73-07b9-4b26-8ca3-8c45fa917571.png?x-oss-process=image%2Fresize%2Cw_1234)
//session的配置和cookie基本一致，可以使用cookie里面的配置  
//设置session cookie里面的key (key: 'EGG_SESS'

![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612332670718-e231e3c6-d3ff-4b5b-9eeb-9787c30871f7.png?x-oss-process=image%2Fresize%2Cw_658)

**session扩展存储**   
Session 默认存放在 Cookie 中，但是如果我们的 Session 对象过于庞大，就会带来一些额外的问题
- 前面提到，浏览器通常都有限制最大的 Cookie 长度，当设置的 Session 过大时，浏览器可能拒绝保存。  
- Cookie 在每次请求时都会带上，当 Session 过大时，每次请求都要额外带上庞大的 Cookie 信息。
我们只需要设置 app.sessionStore 即可将 Session 存储到指定的存储中  
sessionStore 的实现我们也可以封装到插件中，例如 egg-session-redis 就提供了将 Session 存储到 redis 中的能力，在应用层，我们只需要引入 egg-redis 和 egg-session-redis 插件即可。

**修改session失效时间**
针对特定用户的 Session 有效时间设置我们可以通过 ctx.session.maxAge= 来实现

**延期session有效期**
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1612332981511-92b074eb-747e-4d63-9576-40e80e2ab145.png?x-oss-process=image%2Fresize%2Cw_1084)

**区别**
两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过去与否可以在cookie生成的时候设置进去。  
(1)cookie数据存放在客户的浏览器上，session数据放在服务器上  
(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session  
(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE  
(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。  
(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中  

**egg view模版渲染**  
https://www.axihe.com/edu/egg/core/view.html
绝大多数情况，我们都需要读取数据后渲染模板，然后呈现给用户。故我们需要引入对应的模板引擎。
框架内置 egg-view 作为模板解决方案，并支持多模板渲染，每个模板引擎都以插件的方式引入，但保持渲染的 API 一致。

**egg错误处理**
- egg-onerror 是框架做兜底的
- 你自己的处理，可以在 Controller / Service 等地方自己 catch
- 或者通过 Middleware 结合 match 来做范围的 catch
  onerror 主要处理全局异常，这类基本都是未捕获异常，也就是应用开发者不知道哪里会抛异常，onerror 是用来兜底的  
  通过 try catch 统一捕获错误  
  提供了 ctx.runInBackground(scope) 辅助方法，通过它又包装了一个异步链，所有在这个 scope 里面的错误都会统一捕获。  
  onerror 插件的配置中支持 errorPageUrl 属性，当配置了 errorPageUrl 时，一旦用户请求线上应用的 HTML 页面异常，就会重定向到这个地址  
  Controller 和 Service 都有可能抛出异常，这也是我们推荐的编码方式，当发现客户端参数传递错误或者调用后端服务异常时，通过抛出异常的方式来进行中断。  
  - Controller 中 this.ctx.validate() 进行参数校验，失败抛出异常。
- Service 中调用 this.ctx.curl() 方法访问 CNode 服务，可能由于网络问题等原因抛出服务端异常。
- Service 中拿到 CNode 服务端返回的结果后，可能会收到请求调用失败的返回结果，此时也会抛出异常。

**中间件统一异常处理**
在接口中先抛出错误
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614012833005-d2c192a0-d3be-4363-bc7a-71d58320abb6.png)

在app文件下创建middleware文件夹，同时创建一个error_handler.js的文件
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614012908758-5fba65c1-ffaf-4948-9ff6-920eb337ded2.png?x-oss-process=image%2Fresize%2Cw_1140)

在config.default.js中配置
![](https://cdn.nlark.com/yuque/0/2021/png/8371569/1614012960788-64a365d0-51cb-4ec2-9554-4590666ef430.png?x-oss-process=image%2Fresize%2Cw_1296)


**egg HttpClient**
架基于 urllib 内置实现了一个 HttpClient，应用可以非常便捷地完成任何 HTTP 请求。
框架在应用初始化的时候，会自动将 HttpClient 初始化到 app.httpclient。 同时增加了一个 app.curl(url, options) 方法，它等价于 app.httpclient.request(url, options)。
这样就可以非常方便地使用 app.curl 方法完成一次 HTTP 请求。
https://www.axihe.com/edu/egg/core/httpclient.html

**egg日志**  
框架内置了强大的企业级日志支持，由 egg-logger 模块提供。  
主要特性：  
- 日志分级
- 统一错误日志，所有 logger 中使用 .error() 打印的 ERROR 级别日志都会打印到统一的错误日志文件中，便于追踪
- 启动日志和运行日志分离
- 自定义日志
- 多进程日志
- 自动切割日志
- 高性能
  https://www.axihe.com/edu/egg/core/logger.html
**egg安全**
https://www.axihe.com/edu/egg/core/security.html

